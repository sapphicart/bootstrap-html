(function() {
  module.exports = (cmdGroups, options, cb) => {
    var Promise, _close, _exitCode, allChildren, betterSpawn, close, closeGroup, done, running, spawn;
    betterSpawn = require("better-spawn");
    Promise = options.Promise || require("yaku");
    allChildren = [];
    running = true;
    _exitCode = 0;
    _close = (children) => {
      var child, closed, j, len;
      closed = [];
      for (j = 0, len = children.length; j < len; j++) {
        child = children[j];
        closed.push(child.close());
      }
      return Promise.all(closed).then(() => {
        return 1;
      });
    };
    closeGroup = (group) => {
      if (group && !group.closed) {
        group.closed = true;
        _close(group.units.map((unit) => {
          return unit.child;
        }));
      }
      return Promise.resolve();
    };
    close = () => {
      if (running = true) {
        running = false;
        return _close(allChildren);
      }
      return Promise.resolve(_exitCode);
    };
    spawn = (unit, group, exitCode) => {
      var child;
      if (running) {
        if (group && unit.master) {
          group.wait = true;
        }
        allChildren.push(child = unit.child = betterSpawn(unit.cmd, {
          noOut: options.silent,
          noErr: options.noErr
        }));
        if (unit.timeout) {
          setTimeout(child.close, unit.timeout);
        }
        return child.closed.then(async(child) => {
          if (!unit.ignore) {
            if (child.exitCode) {
              if (group && !group.closed) {
                if (!group.wait) {
                  await closeGroup(group);
                }
              } else {
                await close();
              }
              return child.exitCode;
            } else {
              if (group && !group.closed) {
                if (group.first || unit.master) {
                  unit.master = true;
                  await closeGroup(group);
                }
              }
            }
          }
          return 0;
        });
      }
      return Promise.resolve(exitCode);
    };
    done = cmdGroups.reduce(((acc, cur) => {
      return acc.then((exitCode) => {
        if (exitCode) {
          return Promise.resolve(exitCode);
        }
        if (cur.parallel) {
          return Promise.all(cur.units.map((unit) => {
            return spawn(unit, cur, exitCode);
          })).then(async(exitCodes) => {
            var i, j, k, len, len1, ref, unit;
            ref = cur.units;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              unit = ref[i];
              if (unit.master) {
                if (exitCodes[i]) {
                  await close();
                }
                return exitCodes[i];
              }
            }
            for (k = 0, len1 = exitCodes.length; k < len1; k++) {
              exitCode = exitCodes[k];
              if (exitCode) {
                await close();
                return exitCode;
              }
            }
            return 0;
          });
        } else {
          return cur.units.reduce(((acc2, cur2) => {
            return acc2.then((exitCode) => {
              return spawn(cur2, null, exitCode);
            });
          }), Promise.resolve(0));
        }
      });
    }), Promise.resolve(0)).then((exitCode) => {
      if (typeof cb === "function") {
        cb(exitCode);
      }
      return _exitCode = exitCode;
    }).catch((e) => {
      return console.log(e);
    });
    return {
      close: close,
      done: done
    };
  };

}).call(this);
